
### 객체지향 
> 응집도를 높이고 결합도를 낮춘다.
### SOLID
    - SRP 1클1일 / OCP 인터페이스사용 / LSP 상위하위변환    / ISP / DIP
    >> SOC 관심사를 분리하면 SOLID는 자연스럽게 구현된다. / 파일갯수는 늘어나지만 유지보수는 쉬워진다.

### ocp? 개방 폐쇄의 원칙
- 변경될것과 변하지 않을것을 구분 
- 만나는지점 인터페이스 정의
- 정의한 인터페이스에 의존하게 코드를 작성
- 기능을 바꾸어도 코드는 그대로 - 왜?-인터페이스니깐



https://dublin-java.tistory.com/48


### proxy-aop
- 대행자
- 객체에 대한 접근을 제어하거나 [기능] 을 추가
ex. 변경하지 않고 시간을 체크 
- 상속extends  , interface 
- lazy initialize 적용 , 권한 체크 등 장점

### 캐시
- appcache - ESO캐시 웹캐시  redis cdn
- http message convertor

### 부하 발생시 대처 순서
1. rdb라면 read  replica로 read  write api를 분산해본다.
2. redis로 잦은 select할 오브젝트 캐시로 db부하를 완화시킨다
3. db를 대규모 트래픽에 대비해 스케일아웃이 가능하도록 nosql로 재 설계해보고
4. db가 뻗을거 대비해 빠른 복구가 가능한 db  proxy를 이용하거나 철저한 백업과 cdc기능으로 sync할 db를 준비해둔다.

## MSA
- 어떤 장점이 있는지
    - 빌드/배포 가 빠르고 대응이 빠르다.  - 장애 발생 시 복구가 쉽다.
    - 동일한 동작을 하는 어플리케이션을 재사용할수 있다. 
    - 책임이 명확한 컴포넌트로 나누어 도메인 전문성을 갖추게 된다. 응집도가 높아진다
    - 프로젝트 복잡도가 감소 한다. 결합도가 낮아진다. 
    - 로드밸런서의 기능을 수행할 수있다.
- 단점이 뭔지 
    - 트렌젝션 관리가 어렵다.  
    - 장애 발생시 추적이 어렵다. 
    - 관리자가 적을경우 모르는 서비스가 생긴다.  - 소스관리

* SAGA
    - 분산 트렌젝션 환경에서 영속성을 유지하기 위한 방법
    - 보상 트렌젝션을 실행 
    - 각각의 상태를 메시지 형태로
        * 코레오그래피 (choregraphy:안무)  : 의사결정을 참여자. 이벤트 교환 방식 통신
            - 중앙편성자가 없음. 다음참여자를 트리거 하는 이벤트 발행
            - 발행 구독 형태로 소통
            * 주의점
                - 원자적으로 일어남
                - 트렌젝셔널 메시징 - 수신받은 데이터와 자신이 가진 데이터를 연관 지을수 있어야함.
            * 장점 : 비지니스별 객체를 생성 단순화, 느슨한 결합 - 이벤트를 구독할뿐 서로 모름
            * 단점 : 구현로직이 흩어져 이해하기 어려움, 모니터링이 어려움, 타임아웃이 어려움 
        * 오케스트레이션 (orchestration:관현악) : 의사결정을 중앙화. 참여자에게 커맨드 메시지를 보냄
            - 커맨드 비동기 응답 상호방식으올 동작
            - 메시지 브로커가 전송
            * 장점: 의존관계 단순화 / 비지니스로직을 단순화
            * 단점 : 잘못된 중앙화 유발 , 중앙서비스가 죽으면 서비스 이용불가
            - 이미 구현된 서비스에 적용하기 좋음 
* CQRS
    > Command and Query Responsibility Segregation(명령과 조회의 책임 분리)

    - CQRS는 시스템의 상태를 변경하는 작업과 시스템의 상태를 반환하는 작업의 책임을 분리하는 것입니다.
    - CQRS는 데이터를 업데이트하는 명령과 데이터를 읽는 쿼리 를 사용하여 읽기 및 쓰기를 다른 모델로 구분 합니다 .
    - 시스템의 제한된 구역에 CQRS 적용을 고려
    - 시간이 흐름에 따라 하나의 모델이 점점 다양한 요구사항을 녹여내기 위해 초기 모델보다 거대해지거나 변질될 수 있습니다.

*이벤트 소싱*이란 
> Application 내의 모든 Activity를 이벤트로 전환해서 이벤트 스트림(Event Stream)을 별도의 Database에 저장하는 방식을 의미합니다. 

    - EvensSourcing Model이란 
        - 이벤트 스트림을 저장하는 Database에는 오직 데이터 추가만 가능하고 계속적으로 쌓이는 데이터를 구체화시키는 시점에서 그때까지 구축된 데이터를 바탕으로 조회 대상 데이터를 작성하는 방법을 의미합니다. 
        - 즉, Application 내의 상태 변경을 이력으로 관리하는 패턴의 발전된 형태로 이해하면 됩니다.
        - insert/update 요청을 이벤트 스토리지에 저장하여 이를 큐 형태로 처리 
        - aws-sns / aws-sqs - 시스템 회복력이 좋아짐
### MSA 적용 순서
    1. 코드분리
    2. 서버분리 api 패턴적용
        2.1 api gw 적용
        2.2 container 적용 검토
    3. db 분리 
        3.1 조인쿼리
        3.2 트렌젝션
            3.2.1 보상트렌젝션 > SAGA 패턴 
        3.3 공통데이터
            3.3.1 VIEW 사용 : 서비스간 데이터 조회를 고려할때는 VIEW사용으로 보안 정보 은닉
            3.3.2 READ DB 구성 - CUD는 API콜, R은 read DB 조회
    

### DDD Domain Driven Development
    실제 행위에 가까운 코드를 작성
    분석 작업과 설계 그리고 구현까지 통일된 방식으로 커뮤니케이션이 가능
### BDD Behavior Driven Development
    TDD와 거의 유사하긴 하지만. 차이가 있다면 TDD는 테스트 자체에 집중해 개발하는 방면, 
    BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 개발
    시나리오 테스트
    메소드 이름을 "이 클래스가 어떤 행위를 해야한다(should do something)" 라는 식의 문장으로 작성해 "행위"를 위한 테스트에 집중
### TDD Test Driven Development
    TDD는 테스트 주도 개발이기 때문에 구현해야할 부분을 코드를 먼저 작성해야 한다.
    실패한 테스트 코드를 성공시키기 위한 최소한의 코드 구현하기

### AOP
    Target- 누구에
    Advice - 무엇을
        @Around 
    Join Point - 어디에
    Point cut - 적용될 지점
        (@annotation / execution *~*)
    
    * @Transactional 이 private mehtod 에 적용 되지 않는 원인?
        - 주입받는 tx에는 proxy로 감싸준 tx가 적용되지 않기때문
        - runtime 에는 주입된 proxy 타입을 사용하기 때문
        - 감싸진 proxy 객체가 아니기때문
        - aop로 감싸지지 않은 객체가 불려짐
    
## k8s ?
> container orchestration 툴
ex) 그외 : docker-swarm, marathon 
helm
- MSA기반의 많은 yaml 을 관리하는 방법
- 버전관리, 대응, 가독성, 설정 최소화 등 장점이 있다.
- kubelet - 노드에서 실행되는 pod에서 container 가 동작하게 관리하는 agent
- kubeproxy - 노드에서 실행되는 네트워크 프록시 네트워크 규칙을 관리 바깥에서 pod 로 네트워크 통신 지원 
- 원칙 : 1container - 1process 

### 전략 패턴
> 동일계열 알고리즘을 정의, 캡슐화하여 상호교체가 가능하게 만든다.
- 인터페이스와 구현으로 나열되는 코드를 줄임. 변하는것을 추상화 (ex.인터페이스 이동/인터페이스 발사)

- 구조 클래스 
    - 컨텍스트-  DI를 통해 전략을 주입 받는곳 -- 합쳐지는 메인클래스
    - 전략 - 알고리즘을 호출하는 방식을 정의 -- 인터페이스
    - 전략구현 - 각 전략 구현 -- 구현 클래스

- 장점 : 상속사용x , if문 제거 , 구현의 선택
- 단점 : 객체 수 증가, 서로 다른 전략을 이해 
- 상태패턴과 차이 ? - 
    - 전략패턴 : 의존성주입 / 상태패턴 : 스스로 상태를 변환 / 알고리즘 변화가 필요할때 적용, 상태변화가 필요할떄 적용 
- is a / has a
- 적용순서
    1. 변경될것, 변경안할부분 지정
    2. 모듈이 만나는점에 인터페이스 정의
    3. 생성 전략클래스에 인터페이스 인스턴스를 넣음 

- 기능이 계속 생겨도 기존 코드는 변경되지 않아 확장이 쉬워짐


