# The Pragmatic Programmer
> 실용주의 프로그래머 - 앤드류헌트, 데이비드 토머스

    어떤 특정기술에 메이면 안되고, 개별상황마다 그 상황에서 좋은 해결방안을 고를 수 있도록 충분한 배경지식 과 경험을 가져야 한다. 배경지식은 컴퓨터 과학의 기본원리를 이해하는것에서 나오고, 경험은 다양한 범위의 실제 프로젝트를 수행하는것에서 나온다.

## 1. 실용주의 철학

### 고양이가 내 소스코드를 삼켰어요
- 자신의 무지나 실수를 인정하기를 두려워하지 않는다.
- 예상치 못한 문제에 정직해져야 한다.
- 위험요소가 있다면 대책을 세워야한다.
### 소프트웨어 엔트로피
> Entropy : 무질서 한 정도를 가르키는 물리학 용어
- 소프트웨어 부패: 소프트웨어의 무질서함이 증가
- 깨진창문이론: 수리되지않고 방치된 창문하나가 거주자에게 버려진 느낌을 스며들게 한다.
- 나쁜설계, 잘못된결정, 형편없는 코드를 내버려 두지 말라.
### 돌맹이 수프
- 시작 피로(Start-up fatigue) 를 두려워하지 마라. 미래를 보여줘라 
- 큰 그림에 늘 주의를 기울여라. 서서히 망가지는 프로젝트에 삶은 개구리가 되지 마라
### 적당히 괜찮은 소프트웨어
- 완벽한것을 만들어 내기란 불가능하다.
- 사용자에게 직접 만져볼수있는것을 주고, 피드백을 통해 개선하자.
### 지식 포트폴리오
- 지식과 경험은 소진되는 자산이다. 이러한일을 예방하자. 
### 소통하라.
> 소통없이는 어떤 아이디어도 고아에 지나지 않는다.

    WISDOM - 청중이해하기
    What - 무엇을 배우길 원하는가
    Interest - 관심있는것은?
    Sophisicated - 기반지식은 ? 
    Detail - 원하는 구체적인 범위?
    Owe - 정보를 소유하길 원하는가?
    Motive - 경청을 유도하기 위한 장치는?
- 말하고싶은것은? 개요를 만들고 스스로 질문하라.

## 2. 실용주의 접근법
> 중복의해악, 직교성, 시간과 자원의 제한, 스케줄링
### 중복의 해악
> DRY (Don`t Repeat Yourself) 반복하지 마라
- 강요된
    - 다양한 플랫폼 - DB Table, Entity Class, View etc. 
    - 주석은 높은수준에서 달자. 낮은 차원의 지식은 코드에 두자.
- 부주의한 - 설계실수 : 객체화 실수 등
- 참을성없는 - 지름길을 택하고 싶은 유혹 (ex. Y2K)
- 개발자간의 - 적극적, 빈번한, 소통

### 직교성
> Independence, Decoupling
>> 하나가 바뀌어도 나머지에 어떤 영향도 주지않으면, 서로 직교한다.

- 비직교적 : 변화 각각이 다른 모든 행위에 영향을 끼친다.
- 컴포넌트가 격리되어 있으면 하나를 바꿀때 나머지 것들을 걱정하지 않아도 된다.
- 장점: 생산성 향상(재사용성 향상), 리스크 감소(감염된 코드 격리)
- 직교적으로 작성된 코드는 테스트 작성 시 다른 영역을 끌어들이지 않는다.


### 가역성
> 최종 결정이란 없다.
- 어떤 사실을 굳게 믿고 그 사실에 전적으로 의존하고 있다면, 거의 100% 그것이 변하게 될 것이라고 이야기해주고 싶다.
- 중요한 결정(데이터베이스, 아키텍쳐패턴, 배포모델 등)을 많이 하게 된다면 매우 큰 차이로 겨냥이 빗나가게 된다.
- 추상화 : 올바르게 추상화 되어 하나의 지점이 서비스를 제공하게 된다면, 도중에 갈아 탈수 있는 유연성을 갖추게 될 것이다.
#### 유연한 아키텍쳐
- 결합도 줄이기
### 예광탄 (Tracer Observation)
> 프로젝트는 완성되는데 시간이 걸리기 때문에, 작업을 둘러싼 환경이 변화하리 라는것도 확실히 장담할 수 있다.

- 예광탄 코드 접근방법
    - 뭔가 작동하는것을 보게 된다.
    - 동료가 들어가서 일할수 있는 구조를 얻는다.
    - 디버깅, 테스트 등 통합작업을 수행할 기반환경이 갖춰진다.
    - 보여줄 것이 생긴다.
    - 사용자에게 진전상황을 이해 시킬수 있다.
#### 예광탄코드 != 프로토타이핑
    예광탄 코드는 프로토 타이핑코드와 다르다.
    프로토 타이핑은 보여주기 용으로 고수준 코드(스크립트코드)로 버리고 다시 짤 수있으나,
    예광탄 코드는 이어서 개발할 수 있게 한다.
### 프로토타입
- 프로토 타입은 꼭 코드로 작성할 필요는 없다. 
- 상황에 따라 예광탄 코드 개발 스타일로 할 필요가 있다.
- 프로토타이핑 코드는 폐기처분할 코드라는것을 꼭 알려주고 이해시켜야 한다.
### 도메인 언어
- 가독성 좋은 언어가 오래간다.
### 추정
- 추정치는 어디서 오는가?
    - 기존에 일을 해봤던사람
    - 무엇을 묻고 있는지 이해하자.
    - 시스템 모델을 만들어보자.
        - 모델을 컴포넌트로 나누어 구체화 해보자.
        - 매개변수에 값을 줘보자.
        - 답을 계산하자.
    - 추정치를 기록 후, 개발 후 실제 결과에 가까운지 판단 후 평가하자.

- 프로젝트 일정 추정하기
    1. 요구사항 체크하기
    2. 위험 분석하기.
    3. 설계, 구현, 통합
    4. 사용자와 함께 검증하기
- 섯부르게 추정하지 마라. 

## 3. 기본적인 도구 
> 도구는 재능을 증폭한다.
특정 통합환경(IDE)을 추구하는것은 실수이다.
### 일반 텍스트의 힘
- 이해할수 있는 형태의 문자로 이루어진 텍스트.
- 지식을 일반 텍스트로 저장해라.
- 사람이 읽을수 있는 형태의 데이터는 다른 형태보다 더 오래 살아남을것이다.
### Shell Games
- GUI 환경의 기능은 설계자의 의도에 따른 제약을 받는다.
- 셸명령은 이해하기 어렵거나 불친절해 보이지만 강력하고 간결하다.
### 파워 에디팅
### 소스코드 관리
- 빌드의 자동화, 반복을 가능하게 한다.
### 디버깅
> 디버깅은 단지 문제 해결 - 버그를 만들어낸 범죄자를 비난하는데 노력하지마라.
>> 비난 대신 문제를 해결해라.
- 버그를 제보한 사용자를 인터뷰할 필요도 있다.
- 최종사용자의 사용패턴 모두를 철저히 테스트 해야한다.
- 데이터 **가시화**가 되어 버그를 미연에 방지한다.
- 트레이싱 - 프로그램의 현재 상태 - 자원누수 등 파악이 편하다.

    **고무오리**  (러버덕)

    문제의 원인을 찾는데는 누군가에게 그걸 설명하는 방법이 있다.
    상대방은 그저 머리를 끄덕이는것만으로 충분하다. (고무오리인척)
    차근차근 설명해 나가는 단순한 행위 그 자체가 문제를 화면에서 뛰쳐나와 스스로 드러나게 하기도 한다.

### 텍스트 처리
- awk sed pythonperl 등 중요 기반기술을 활용
### 코드 생성기
> 코드를 작성하는 코드, 능동적, 수동적
- 타이핑을 줄여준다.
- DB스키마로 부터 코드를 생성

## 4. 실용주의 편집증
- 코드는 모든걸 책임지려고 하지말고 게으르고 계약에 있는 내용만 작성해라 
- 단정적으로 짜지마라 (카운트는 음수, 2자리수 이상의 년도 계산 등)

## 5. Bend or Break
- 결합도 줄이기
    - 점조직으로 코드를 작성해라
- 작업 흐름을 기록하라
    - flow chart UML 사용
- 나눠서 정복해라
    - Publihser / Subscriber
    - message 기반 event driven 방식 

## 6. 코딩하는동안 해야 할 일
- 왜 잘돌아가는지 모르면 왜 안돌아가는지 모르게된다.
